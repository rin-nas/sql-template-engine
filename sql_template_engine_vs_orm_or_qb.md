
# Сравнение SQL шаблонизатора, ORM и QueryBuilder

## Введение
Принцип [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) утверждает, что большинство систем работают лучше всего, если они остаются [простыми](https://yandex.ru/yandsearch?text=%D0%AD%D0%B4%D1%81%D0%B3%D0%B5%D1%80%20%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D0%B0%3A%20%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D0%B0%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BD%D0%B5%D0%BF%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5%20%D0%B4%D0%BB%D1%8F%20%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%D0%B4%D0%B5%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8&lr=10740), а не усложняются. В области проектирования IT решений простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

* Описание принципов работы [SQL шаблонизатора](https://github.com/rin-nas/sql-template-engine/blob/master/README.md)
* По [ORM](https://ru.wikipedia.org/wiki/ORM) ознакомьтесь [с этой статьёй на Хабре](https://m.habr.com/company/pgdayrussia/blog/328690/).
* По QueryBuilder ознакомьтесь с разделом документации [Laravel](http://laravel.su/docs/5.5/queries) и/или [Doctrine](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html).

## Сокращения
* ORM — Object-Relational Mapping
* QB — QueryBuilder

## Подробная таблица сравнения
\#| Критерий | SQL шаблонизатор | ORM или QueryBuilder
--|----------|------------------|---------------------
1 | Размер исходного кода | 10К | 50К и более. Больший размер кода с большим количеством логики может содержать больше ошибок
2 | Порог вхождения программиста перед началом работы| Меньше. Достаточно изучить несколько простых типов меток-заменителей и одно правило условного блока| Больше. Нужно изучить десятки методов с их параметрами
3 | Перегенерация моделей каждый раз при изменении схемы БД| Не нужно | Нужно. Это занимает лишнее время, в логике генератора могут быть ошибки.
4 | Быстрое создание нового запроса к БД | Да. Только расстановка меток-заменителей в SQL запросе | Нет. Необходимо переписывать SQL запрос после его создания в набор методов ORM/QB, это лишние затраты времени
5 | Быстрая модификация существующего запроса к БД | Да. SQL запрос можно дописать сколько угодно сложным SQL кодом. | Нет. При усложнении логики возможностей ORM уже не хватает и тогда нужно переписывать обратно в SQL. Сложный запрос в QB может стать слабо читабельным и трудноподдерживаемым
6 | Скорость генерации SQL | Быстрее. Простой парсер без использования регулярных выражений работает очень быстро. Парсер на базе рег. выражений работает не медленнее ORM или QB | Медленнее. Ещё один слой абстакции с дополнительной логикой, которая может содержать ошибки
7 | Оптимальность генерации SQL | Да. Выполяется именно тот запрос, который задумал разработчик. | Нет. Вместо 1-го SQL запроса их может быть десятки, что плохо сказывается на общем времени выполнения
8 | Поиск медленных запросов для оптимизации | Легче. SQL запрос можно найти в исходном коде по совпадению фрагментов | Труднее. Запрос генерируется и найти это место в коде трудно, если ORM или QB не записывает в комментарий перед запросом указатель на место в исходном коде
9 | Результат в виде вложенных объектов | Да. За 1 SQL запрос можно получить результат сколь угодно сложной структуры, возвращая [JSON](https://ru.wikipedia.org/wiki/JSON) и затем декодируя его. По сути это аналог объектов, хотя и не полноценный (есть свойства, но нет методов). Но методы могут не понадобиться так так все данные, скорее всего уже получены в 1-м SQL запросе. При острой необходимости можно сделать экспорт данных в полноценные объекты | Да. Но на каждый объект будет как минимум 1 SQL запрос, что плохо скажется на производителности
10 | Кэширование запросов (в памяти) | Хуже. Кеширование работает только для запроса целиком для всех получаемых объектов. Но кэширование отдельных объектов скорее всего не понадобится, так так все объекты уже получены в 1-м SQL запросе. | Лучше. Продвинутые ORM или QB могут кешировать каждый экземпляр объекта независимо.
11 | Скорость (а так же удобство и гибкость) разработки | Хуже. Могут присутствовать дубликаты SQL кода. В случае изменения логики нужно править во многих местах. Но в этом случае такая множественная правка будет одновременно валидацией необходимости правок в каждом месте | Лучше. Одинаковые части выносятся в отдельные методы объектов. С объектами легче манипулировать

## Итоговая таблица сравнения

\#| Критерий                      | SQL шаблонизатор | ORM или QueryBuilder | Степень отличия
--|-------------------------------|------------------|----------------------|------------------
1 | Общая скорость разработки и поддержки | Медленнее        | Быстрее              | не значительно
2 | Общая производительность кода | Быстрее          | Медленнее            | может быть в разы
3 | Общая стабильность кода       | Лучше            | Хуже                 | может быть в разы

## Выводы
ORM или QB могут применяться в начале пути, когда важна скорость разработки: для быстрого построения оценочных прототипов и [MVP](https://en.wikipedia.org/wiki/Minimum_viable_product). 
Для быстроработающей и надёжной функциональности нужен SQL шаблонизатор.
